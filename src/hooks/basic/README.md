---

## ⚠️ 闭包陷阱说明：为什么推荐使用函数式更新？

### ❌ 错误示例：直接使用旧值

```tsx
const handleAsyncIncrement = () => {
  setTimeout(() => {
    setCount(count + 1); // 闭包陷阱：这里的 count 是旧的快照值
  }, 1000);
};
```

- 这里的 `count` 是点击按钮时的**快照值**
- 如果中间有其他状态更新，这里加的就不是“最新”的 count

---

### ✅ 正确示例：使用函数式更新

```tsx
const handleSafeAsyncIncrement = () => {
  setTimeout(() => {
    setCount(prev => prev + 1); // 始终基于最新状态值
  }, 1000);
};
```

- `prev` 是 React 内部提供的**当前最新的状态值**
- 即使有多个异步操作，也不会丢失状态或覆盖错误

---

### ✅ 总结建议

| 写法                     | 场景           | 是否安全 |
|--------------------------|----------------|-----------|
| `setCount(count + 1)`    | 同步操作       | ✅ 大多数时候没问题，但要小心闭包 |
| `setCount(prev => prev + 1)` | 异步/高频更新 | ✅ 推荐写法，最安全 |

---